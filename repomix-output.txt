This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-02T16:35:02.003Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
db/
  db.go
handlers/
  getHandler.go
  postHandler.go
  rootHandler.go
  types.go
  utils.go
middleware/
  logging.go
models/
  urlModel.go
services/
  base62.go
.air.toml
.gitignore
Dockerfile
fly.toml
go.mod
go.sum
LICENSE
main.go
README.md

================================================================
Repository Files
================================================================

================
File: db/db.go
================
// db/db.go
package db

import (
	"database/sql"
	"log"
	"os"

	_ "github.com/lib/pq"
)

var DB *sql.DB

func InitDB() {
	// Get DB URL from environment variable
	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		log.Fatal("DATABASE_URL environment variable is not set")
	}

	var err error
	DB, err = sql.Open("postgres", dbURL)
	if err != nil {
		log.Fatalf("Error opening database: %v\n", err)
	}

	err = DB.Ping()
	if err != nil {
		log.Fatalf("Error connecting to the database: %v\n", err)
	}

	// Create tables if they don't exist
	_, err = DB.Exec(`
		CREATE TABLE IF NOT EXISTS urls (
			id VARCHAR(4) PRIMARY KEY,
			original_url TEXT NOT NULL,
			new_url TEXT NOT NULL,
			created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		log.Fatalf("Error creating table: %v\n", err)
	}
}

================
File: handlers/getHandler.go
================
package handlers

import (
	"database/sql"
	"net/http"

	"jeorozco.com/go/url-shortener/models"
)

func GetURL(w http.ResponseWriter, r *http.Request) {
	urlID := r.PathValue("id")
	url, err := models.GetByID(urlID)
	if err != nil {
		if err == sql.ErrNoRows {
			sendErrorResponse(w, "URL not found", http.StatusNotFound)
			return
		}
		sendErrorResponse(w, "Server error", http.StatusInternalServerError)
		return
	}

	sendJSONResponse(w, url.OriginalURL, http.StatusOK)
}

================
File: handlers/postHandler.go
================
package handlers

import (
	"encoding/json"
	"net/http"

	"jeorozco.com/go/url-shortener/models"
)

func CreateURL(w http.ResponseWriter, r *http.Request) {
	var url models.LongURL
	err := json.NewDecoder(r.Body).Decode(&url)
	if err != nil {
		sendErrorResponse(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if url.Url == "" {
		sendErrorResponse(w, "URL is required", http.StatusBadRequest)
		return
	}

	shortURL, err := models.New(url)
	if err != nil {
		sendErrorResponse(w, "Failed to create short URL", http.StatusInternalServerError)
		return
	}

	response := URLResponse{
		ShortURL: shortURL.NewURL,
	}

	sendJSONResponse(w, response, http.StatusCreated)
}

================
File: handlers/rootHandler.go
================
package handlers

import (
	"fmt"
	"net/http"
)

func HandleRoot(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "Hello World")
}

================
File: handlers/types.go
================
package handlers

// Response types
type URLResponse struct {
	ShortURL string `json:"short_url"`
}

type ErrorResponse struct {
	Error string `json:"error"`
}

================
File: handlers/utils.go
================
package handlers

import (
	"encoding/json"
	"net/http"
)

func sendJSONResponse(w http.ResponseWriter, data interface{}, statusCode int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	if err := json.NewEncoder(w).Encode(data); err != nil {
		http.Error(w, "Failed to encode response", http.StatusInternalServerError)
	}
}

func sendErrorResponse(w http.ResponseWriter, message string, statusCode int) {
	response := ErrorResponse{
		Error: message,
	}
	sendJSONResponse(w, response, statusCode)
}

================
File: middleware/logging.go
================
package middleware

import (
	"log"
	"net/http"
	"time"
)

type wrappedWriter struct {
	http.ResponseWriter
	statusCode int
}

func (w *wrappedWriter) WriteHeader(statusCode int) {
	w.ResponseWriter.WriteHeader(statusCode)
	w.statusCode = statusCode
}

func Logging(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		wrapped := &wrappedWriter{
			ResponseWriter: w,
			statusCode:     http.StatusOK,
		}

		next.ServeHTTP(wrapped, r)

		log.Println(wrapped.statusCode, r.Method, r.URL.Path, time.Since(start))
	})
}

================
File: models/urlModel.go
================
// models/urlModel.go
package models

import (
	"time"

	"jeorozco.com/go/url-shortener/db"
	"jeorozco.com/go/url-shortener/services"

	"github.com/google/uuid"
)

type ShortURL struct {
	ID          string    `json:"id"`
	OriginalURL string    `json:"original_url"`
	NewURL      string    `json:"short_url"`
	CreatedAt   time.Time `json:"created_at"`
}

type LongURL struct {
	Url string `json:"url"`
}

func New(url LongURL) (ShortURL, error) {
	encoded := services.UUIDToShortID(uuid.New())
	baseURL := "https://www.nanourl-dev.xyz" // Update this with your fly.io domain
	newURL := baseURL + "/" + encoded

	shortURL := ShortURL{
		ID:          encoded,
		OriginalURL: url.Url,
		NewURL:      newURL,
		CreatedAt:   time.Now().UTC(),
	}

	// Insert into database
	_, err := db.DB.Exec(
		`INSERT INTO urls (id, original_url, new_url, created_at) 
		 VALUES ($1, $2, $3, $4)`,
		shortURL.ID, shortURL.OriginalURL, shortURL.NewURL, shortURL.CreatedAt,
	)
	if err != nil {
		return ShortURL{}, err
	}

	return shortURL, nil
}

func GetByID(id string) (ShortURL, error) {
	var url ShortURL
	err := db.DB.QueryRow(
		`SELECT id, original_url, new_url, created_at 
		 FROM urls WHERE id = $1`,
		id,
	).Scan(&url.ID, &url.OriginalURL, &url.NewURL, &url.CreatedAt)
	return url, err
}

================
File: services/base62.go
================
package services

import (
	"crypto/sha256"
	"encoding/binary"
	"math/big"

	"github.com/google/uuid"
)


const base62Chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

// UUIDToShortID converts a UUID to a 4-character base62 ID
func UUIDToShortID(u uuid.UUID) string {
	// Hash the UUID to get a more uniform distribution
	hash := sha256.Sum256(u[:])

	// Take the first 4 bytes of the hash and convert to uint32
	num := binary.BigEndian.Uint32(hash[:4])

	// Convert to base62
	return encodeBase62(big.NewInt(int64(num)))[:4]
}

// encodeBase62 encodes a big.Int to a base62 string
func encodeBase62(n *big.Int) string {
	if n.Sign() == 0 {
		return string(base62Chars[0])
	}

	chars := []byte{}
	base := big.NewInt(62)
	zero := big.NewInt(0)
	mod := new(big.Int)

	for n.Cmp(zero) > 0 {
		n.DivMod(n, base, mod)
		chars = append(chars, base62Chars[mod.Int64()])
	}

	// Reverse the characters
	for i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {
		chars[i], chars[j] = chars[j], chars[i]
	}

	return string(chars)
}

================
File: .air.toml
================
root = "."
testdata_dir = "testdata"
tmp_dir = "tmp"

[build]
  args_bin = []
  bin = "./tmp/main"
  cmd = "go build -o ./tmp/main ."
  delay = 1000
  exclude_dir = ["assets", "tmp", "vendor", "testdata"]
  exclude_file = []
  exclude_regex = ["_test.go"]
  exclude_unchanged = false
  follow_symlink = false
  full_bin = ""
  include_dir = []
  include_ext = ["go", "tpl", "tmpl", "html"]
  include_file = []
  kill_delay = "0s"
  log = "build-errors.log"
  poll = false
  poll_interval = 0
  post_cmd = []
  pre_cmd = []
  rerun = false
  rerun_delay = 500
  send_interrupt = false
  stop_on_error = false

[color]
  app = ""
  build = "yellow"
  main = "magenta"
  runner = "green"
  watcher = "cyan"

[log]
  main_only = false
  time = false

[misc]
  clean_on_exit = false

[proxy]
  app_port = 0
  enabled = false
  proxy_port = 0

[screen]
  clear_on_rebuild = false
  keep_scroll = true

================
File: .gitignore
================
# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum
*.o
*.a
*.so
*.test
*.prof
*.out

vendor/
tmp/

# IDE specific files
.vscode
.idea

# build output
air

================
File: Dockerfile
================
ARG GO_VERSION=1
FROM golang:${GO_VERSION}-bookworm as builder

WORKDIR /usr/src/app
COPY go.mod go.sum ./
RUN go mod download && go mod verify
COPY . .
RUN go build -v -o /run-app .


FROM debian:bookworm

COPY --from=builder /run-app /usr/local/bin/
CMD ["run-app"]

================
File: fly.toml
================
# fly.toml app configuration file generated for nanourl-be on 2024-10-30T22:53:22Z
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.
#

app = 'nanourl-be'
primary_region = 'ord'

[build]
[build.args]
GO_VERSION = '1.22.5'

[env]
PORT = '8080'
ALLOWED_ORIGINS = "http://localhost:5173,http://localhost:3000,https://www.nanourl-dev.xyz/"
CORS_DEBUG = "false"

[http_service]
internal_port = 8080
force_https = true
auto_stop_machines = 'stop'
auto_start_machines = true
min_machines_running = 0
processes = ['app']

[[vm]]
memory = '1gb'
cpu_kind = 'shared'
cpus = 1

================
File: go.mod
================
module jeorozco.com/go/url-shortener

go 1.22.5

require github.com/google/uuid v1.6.0 // direct

require github.com/rs/cors v1.11.0 // direct

require github.com/lib/pq v1.10.9

================
File: go.sum
================
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/rs/cors v1.11.0 h1:0B9GE/r9Bc2UxRMMtymBkHTenPkHDv0CW4Y98GBY+po=
github.com/rs/cors v1.11.0/go.mod h1:XyqrcTp5zjWr1wsJ8PIRZssZ8b/WMcMf71DJnit4EMU=

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Julio Orozco

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: main.go
================
package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"time"

	"github.com/rs/cors"
	"jeorozco.com/go/url-shortener/db"
	"jeorozco.com/go/url-shortener/handlers"
	"jeorozco.com/go/url-shortener/middleware"
)

// getEnv retrieves environment variable or returns default value
func getEnv(key, fallback string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return fallback
}

// getCORSOrigins splits the CORS_ORIGINS environment variable into a slice
func getCORSOrigins() []string {
	origins := getEnv("CORS_ORIGINS", "https://www.nanourl-dev.xyz")
	return strings.Split(origins, ",")
}

func main() {
	// Initialize database
	db.InitDB()
	defer db.DB.Close()

	// Create new mux
	mux := http.NewServeMux()

	// Register routes
	mux.HandleFunc("POST /url", handlers.CreateURL)
	mux.HandleFunc("GET /{id}", handlers.GetURL)

	// Configure CORS
	corsOptions := cors.Options{
		AllowedOrigins: getCORSOrigins(),
		AllowedMethods: []string{
			http.MethodGet,
			http.MethodPost,
			http.MethodOptions,
		},
		AllowedHeaders: []string{
			"Accept",
			"Authorization",
			"Content-Type",
			"X-CSRF-Token",
		},
		AllowCredentials: true,
		// Enable Debugging for testing
		Debug: getEnv("CORS_DEBUG", "false") == "true",
	}

	// Create handler chain
	handler := cors.New(corsOptions).Handler(mux)
	loggingHandler := middleware.Logging(handler)

	// Configure server
	port := getEnv("PORT", "8080")
	server := &http.Server{
		Addr:         ":" + port,
		Handler:      loggingHandler,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	// Start server
	go func() {
		log.Printf("Server starting on port %s\n", port)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Error starting server: %v\n", err)
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt)
	<-quit
	log.Println("Server is shutting down...")

	// Create shutdown deadline
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Attempt graceful shutdown
	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf("Error during server shutdown: %v\n", err)
	}

	log.Println("Server exited properly")
}

================
File: README.md
================
# Go URL Shortener Service

A high-performance URL shortener service built with Go, featuring PostgreSQL persistence, configurable CORS, and production-ready deployment configuration for fly.io.

## Table of Contents
- [Features](#features)
- [Tech Stack](#tech-stack)
- [Prerequisites](#prerequisites)
- [Local Development](#local-development)
- [API Documentation](#api-documentation)
- [Project Structure](#project-structure)
- [Deployment](#deployment)
- [Environment Variables](#environment-variables)
- [Database](#database)
- [Monitoring](#monitoring)
- [Security](#security)
- [Contributing](#contributing)
- [License](#license)

## Features

- âš¡ Fast URL shortening using base62 encoding
- ðŸ”’ Persistent storage with PostgreSQL
- ðŸ“ RESTful API endpoints
- ðŸš€ Production-ready deployment configuration
- ðŸ”‘ Configurable CORS for multiple origins
- ðŸ“Š Request logging middleware
- âŒ› Graceful shutdown handling
- ðŸ›¡ï¸ Security best practices
- âš™ï¸ Environment-based configuration
- ðŸ“ˆ Performance optimized

## Tech Stack

- Go 1.22+
- PostgreSQL
- fly.io for deployment
- CORS middleware (rs/cors)
- UUID generation (google/uuid)
- Connection pooling
- Graceful shutdown handling

## Prerequisites

- Go 1.22 or higher
- PostgreSQL
- [flyctl CLI](https://fly.io/docs/hands-on/install-flyctl/)
- Git

## Local Development

1. **Clone the repository**
   ```bash
   git clone https://github.com/yourusername/url-shortener.git
   cd url-shortener
   ```

2. **Install dependencies**
   ```bash
   go mod download
   ```

3. **Set up environment variables**
   ```bash
   export DATABASE_URL="postgresql://username:password@localhost:5432/urlshortener?sslmode=disable"
   export ALLOWED_ORIGINS="http://localhost:5173,http://localhost:3000"
   export CORS_DEBUG="true"
   ```

4. **Create and initialize database**
   ```bash
   createdb urlshortener
   ```

5. **Run the application**
   ```bash
   go run main.go
   ```
   Server will start on `http://localhost:8080`

6. **Run tests**
   ```bash
   go test ./...
   ```

## API Documentation

### Create Short URL
**POST** `/url`

Request:
```json
{
  "url": "https://example.com/very-long-url"
}
```

Response:
```json
{
  "short_url": "http://yourdomain.fly.dev/Ab3x"
}
```

### Get Original URL
**GET** `/{id}`

Response:
- Success: Original URL as JSON string
- Not Found: 404 status code
- Error: 500 status code

## Project Structure
```
â”œâ”€â”€ db/
â”‚   â””â”€â”€ db.go           # Database connection and initialization
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ getHandler.go   # GET endpoint handler
â”‚   â”œâ”€â”€ postHandler.go  # POST endpoint handler
â”‚   â””â”€â”€ rootHandler.go  # Root endpoint handler
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ logging.go      # Logging middleware
â”œâ”€â”€ models/
â”‚   â””â”€â”€ urlModel.go     # URL data model and database operations
â”œâ”€â”€ services/
â”‚   â””â”€â”€ base62.go       # Base62 encoding service
â”œâ”€â”€ Dockerfile          # Container configuration
â”œâ”€â”€ fly.toml            # fly.io configuration
â”œâ”€â”€ go.mod             
â”œâ”€â”€ go.sum
â”œâ”€â”€ main.go            # Application entry point
â””â”€â”€ README.md
```

## Deployment

### Initial Setup
1. **Install flyctl and login**
   ```bash
   curl -L https://fly.io/install.sh | sh
   fly auth login
   ```

2. **Initialize fly.io project**
   ```bash
   fly launch
   ```

3. **Create PostgreSQL database**
   ```bash
   fly postgres create --name your-app-db
   fly postgres attach your-app-db
   ```

### Environment Configuration
1. **Set required secrets**
   ```bash
   fly secrets set ALLOWED_ORIGINS="https://your-production-frontend.com"
   fly secrets set CORS_DEBUG="false"
   ```

2. **Deploy the application**
   ```bash
   fly deploy
   ```

### Scaling (Optional)
```bash
# Set the number of instances
fly scale count 2

# Configure machine size
fly scale vm shared-cpu-1x
```

## Environment Variables

### Required Variables
- `DATABASE_URL`: PostgreSQL connection string (automatically set by fly.io)

### Optional Variables
- `PORT`: Application port (default: 8080)
- `ALLOWED_ORIGINS`: Comma-separated list of allowed CORS origins 
  - Default: "http://localhost:5173,http://localhost:3000"
  - Example: "http://localhost:5173,https://your-production-frontend.com"
- `CORS_DEBUG`: Enable CORS debug logging (default: "false")

### Local Configuration Example
```bash
export DATABASE_URL="postgresql://username:password@localhost:5432/urlshortener?sslmode=disable"
export ALLOWED_ORIGINS="http://localhost:5173,http://localhost:3000"
export CORS_DEBUG="true"
```

## Database

### Schema
```sql
CREATE TABLE urls (
    id VARCHAR(4) PRIMARY KEY,
    original_url TEXT NOT NULL,
    new_url TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

### Connection Configuration
- Connection pooling enabled
- Configurable timeouts
- Automatic reconnection handling
- Prepared statement support

## Monitoring

### View Application Logs
```bash
fly logs
```

### Check Application Status
```bash
fly status
```

### Database Management
```bash
# Connect to PostgreSQL console
fly postgres connect -a your-app-db

# Monitor database metrics
fly postgres metrics -a your-app-db
```

### Performance Monitoring
- Request logging with duration tracking
- Database query monitoring
- Error rate tracking
- Response time metrics

## Security

### CORS Configuration
- Configurable allowed origins
- Secure default headers
- Credentials handling
- Preflight request support

### Best Practices
- Input validation
- Prepared statements for SQL
- Rate limiting support
- Secure headers
- TLS enforcement
- Graceful error handling

## Error Handling

The service implements comprehensive error handling:
- Invalid URLs return 400 Bad Request
- Not found URLs return 404 Not Found
- Server errors return 500 Internal Server Error
- All errors are logged with timestamps and request IDs
- Structured error responses

## Performance Considerations

- Efficient base62 encoding
- Database connection pooling
- Proper mutex handling
- Response caching capability
- Optimized database queries
- Memory usage optimization

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

### Development Guidelines
- Follow Go best practices and idioms
- Maintain test coverage
- Document public functions
- Use meaningful commit messages
- Update documentation as needed

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Support

For support:
- Open an issue in the GitHub repository
- Check existing documentation
- Contact the maintenance team

## Acknowledgments

- [fly.io](https://fly.io) for deployment platform
- [PostgreSQL](https://www.postgresql.org/) for database
- All contributors and maintainers

---

Developed with â¤ï¸ by [Your Name/Organization]
